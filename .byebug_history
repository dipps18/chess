cont
valid_move?([1,5], piece.pos, piece.color, true, piece)
valid_move?([1,5], piece.pos, piece.color, capture, piece)
valid_move?(move, piece.pos, piece.color, capture, piece)
move
next
capture
move
piece
next
piece
input
color
next
valid_move
next
valid_move
check?(color)
check?(color
input
piece
next
piece
@board.white[:queen]
next
captured_piece
next
step
capture
opp_color
next
opp_color
next
step
capture
next
capture
move
step
piece
next
piece
next
piece
next
piece
next
piece
next
valid_move?(move, piece.pos, piece.color, capture, piece)
piece
next
piece
next
piece
next
piece
next
piece
next
piece
next
piece
step
pieces.values.flatten.none?{|piece| piece.next_moves.any?{|move| valid_move?(move, piece.pos, piece.color, false, piece)}}
pieces.values.flatten.select{|piece| piece.next_moves.any?{|move| valid_move?(move, piece.pos, piece.color, false, piece)}}
pieces
next
pieces
input
color
cont
exit
board.white[:bishops]
pieces.values.flatten.select{|piece| piece.next_moves.any?{|move| valid_move?(move, piece.pos, piece.color, false, piece)}}
pieces.values.flatten.none?{|piece| piece.next_moves.any?{|move| valid_move?(move, piece.pos, piece.color, false, piece)}}
end
valid_move?(move, piece.pos, piece.color, false, piece)
piece.next_moves.any? do |move|
pieces.values.flatten.none? do |piece|
pieces
next
piece
color_pieces(color)
pieces
next
input
color
step
exit
!input.include?('+') && check?(color)
input.include?('+') && !check?(color)
color
opp_color
input
exit
piece
pieces
next
pieces
color
@board.black
opp_pieces
next
opp_pieces
input
piece
color
step
next
input
step
valid_move
piece
next
piece
next
captured_piece
next
captured_piece
next
opp_color
next
opp_color
next
step
capture
next
piece
next
piece
next
old_pos
next
new_pos
next
new_pos
next
valid_move_input?(input)
color
input
cont
exit
checkmate?(color)
input.include?('#')
valid_notation?(input, opp_color)
valid_notation
valid_move
piece
next
piece
input
next
input
step
input
next
valid_move
piece
input
next
input
next
input
next
color
input
step
piece
valid_move
opp_color
input
next
input
next
input
next
input
step
valid_move
opp_color
next
opp_color
next
opp_color
step
valid_move
next
input
cont
exit
@board.white[:pawns].select{|pawn| pawn.next_moves.include?([3, 3])}
@board.black[:pawns][3]
@board.black[:pawns][4]
@board.black[:pawns[4]
@board.white[:pawns][3]
@board.white[:pawns][4]
step
new_pos
next
new_pos
next
step
cont
board.display_board
opp_pawns
enpassant?([@pos[0], @pos[1] + offset_x], opp_pawns)
enpassant?([@pos[0], @pos[1] + offset_x])
enpassant?(@pos[0], @pos[1] + offset_x]
diagonal
step
next
board.out_of_bounds?(diagonal)
out_of_bounds?(diagonal)
[@pos[0], @pos[1] + offset_x]
diagonal
@diagonal
next
diagonal
[@pos[0], @pos[1] + offset_x]
offset_x
step
next
step
exit
@pos[0]
enpassant?([@pos[0], @pos[1] + offset_x])
moves
next
offset_y
moves
next
[@pos[0] + offset_y, @pos[1]]
@pos[0] + offset_y, @pos[1]
next
step
next_pos
next
board.black[:pawns].select{|pawn| pawn.enpossible == true }
next
step
piece
exit
@board.white[:pawns].select{|pawn| pawn.next_moves.include?([3, 3])}
@board.white[:pawns].select{|pawn| pawn.next_moves.include([3, 3])}
@board.white[:pawns].select{|pawn| pawn.next_pos.include([3, 3])}
@board.black[:pawns].select{|pawn| pawn.enpossible == true}
cont
exit
@board.black[:pawns]
piece
step
@board.black[:pawns]
@board.black[:pawns].select{|pawn| pawn.enpossible == true}
@board.black[:pawns].select{|pawn| pawn.enpossible = true}
@board.black[:pawns]
